//.#       0 1 2 3  4  5  6
//.base = [8,9,5,7,13,17,11]
//.rns0 = rnsv('rns0', base)
//.rns1 = rnsv('rns1', [17,11,16])
//.+sec.rns2bin('rns2bin.sv')
// rns2bin (RNS-to-Binary converter)
//.#fast()
//.include_structs(rns0.base, "rns0")
//.include_structs(rns1.base, "rns1")
//.rns0.includes > ''
//.rns1.includes > ''
module rns2bin(
	       output logic [21:0] y,
	       output logic ready,
	       input rns0 x,
	       input logic clk,
	       input logic rst
);
   //.x = rns0('no declaration').x
   //.rns0.declarations > ''
   //.rns1.declarations > ''
   //.rns0.instances > ''
   //.rns1.instances > ''
   // convert first residue (mod 8) to y[2:0]
   enc3 ienc0(.y(y[2:0]), .x(x.x8));
   enc4 ienc1(.y(y[6:3]), .x(d0.x16));
   
   //.rns0.comb > ''
   //.rns1.comb > ''
   assign @x1:=rns0.x1@ = @(x[1:] - x[0])/base[0]@;
   assign x1e0 = @(x1[1:] == 0)@;
   assign @k00:=rns0.k00@ = @-x1[1:2]/16@;
   assign @x00:=rns0.x00@ = @(x1[2:] + k00[1]*16)/base[1]@;
   assign @k01:=rns0.k01@ = @-x00[2:3]/16@;
   assign @x01:=rns0.x01@ = @(x00[3:] + k01[2]*16)/base[2]@;
   assign @k02:=rns0.k02@ = @-x01[3:4]/16@;
   assign @x02:=rns0.x02@ = @(x01[4:] + k02[3]*16)/base[3]@;
   assign @k03:=rns0.k03@ = @-x02[4:5]/16@;
   assign @x03:=rns0.x03@ = @(x02[5:] + k03[4]*16)/base[4]@;
   // normalize x03 (mod 16) so result < 16
   assign @t0:=rns0.t0@ = @(x03[6:] - x03[5])/base[5]@;
   // need some way of doing mod 16 addition here
   //.n0 = rns1.n0
   //.n0.xmods[0] = x03.xmods[5].copy()  ## mod 17
   //.n0.xmods[1] = t0.xmods[6].copy()   ## mod 11
   xm17 = @x03[5] >> 17@;
   xm11 = @t0[6] >> 11@;
   @x1[2:] + k00[2:][1] * 16@
	  
   
   assign @n1:=rns1.n1@ = @n0[2:][0] + n0[2:][1]@;
   assign @d0:=rns1.d0@ = x1e0 ? @rns1(0)@ : @16 - n1[2:]@;
   
   // Testing..
   //.#assign @rns0.z@ = @22 - 3 * (1 + x)@;
   
   //.if dumpvcd:{
   initial begin
      $dumpfile("dump.vcd");
      $dumpvars;
   end      
   //.}

   // SV Assertions
   //.rns0.sva > ''
   //.rns1.sva > ''

endmodule // rns2bin
//.-sec.rns2bin
