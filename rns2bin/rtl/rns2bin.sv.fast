//.#       0 1 2 3  4  5  6
//.base = [8,9,5,7,13,17,11]
//.rns0 = rnsv('rns0', base)
//.rns1 = rnsv('rns1', [16])
//.+sec.rns2bin('rns2bin.sv')
// rns2bin (RNS-to-Binary converter)
//.#fast()
//.include_structs(rns0.base, "rns0")
//.include_structs(rns1.base, "rns1")
//.rns0.includes > ''
//.rns1.includes > ''
module rns2bin(
	       output logic [21:0] y,
	       output logic ready,
	       input rns0 x,
	       input logic clk,
	       input logic rst
);
   //.x = rns0('no declaration').x
   //.rns0.declarations > ''
   //.rns1.declarations > ''
   //.rns0.instances > ''
   //.rns1.instances > ''
   // convert first residue (mod 8) to y[2:0]
   enc3 ienc0(.y(y[2:0]), .x(x.x8));
   enc4 ienc1(.y(y[6:3]), .x(d0));
   
   //.rns0.comb > ''
   //.rns1.comb > ''
   assign @x1:=rns0.x1@ = @(x[1:] - x[0])/base[0]@;
   assign x1e0 = @(x1[1:] == 0)@;
   assign @k00:=rns0.k00@ = @-x1[1:2]/16@;
   assign @x00:=rns0.x00@ = @(x1[2:] + k00[1]*16)/base[1]@;
   assign @k01:=rns0.k01@ = @-x00[2:3]/16@;
   assign @x01:=rns0.x01@ = @(x00[3:] + k01[2]*16)/base[2]@;
   assign @k02:=rns0.k02@ = @-x01[3:4]/16@;
   assign @x02:=rns0.x02@ = @(x01[4:] + k02[3]*16)/base[3]@;
   assign @k03:=rns0.k03@ = @-x02[4:5]/16@;
   assign @x03:=rns0.x03@ = @(x02[5:] + k03[4]*16)/base[4]@;
   // normalize x03 (mod 16) so result < 16
   //.# assign @t0:=rns0.t0@ = @(x03[6:] - x03[5])/base[5]@;
   assign @t0:=rns0.xmod("t0",11)@ = @(x03[6] - (x03[5]>>11))/base[5]@
   assign @xm16:=rns0.xmod("xm16",16)@ = @(x03[5]>>16) + (t0>>16)@;
   //.# assign @d0:=rns1.d0@ = x1e0 ? @rns1(0)@ : @d0 << (16 - xm16)@;
   assign @d0:=rns0.xmod("d0",16)@ = x1e0 ? @rns0.xmod(0,16)@ : @16 - xm16@;

   // Testing..
   //.#assign @rns0.z@ = @22 - 3 * (1 + x)@;
   
   //.if dumpvcd:{
   initial begin
      $dumpfile("dump.vcd");
      $dumpvars;
   end      
   //.}

   // SV Assertions
   //.rns0.sva > ''
   //.rns1.sva > ''

endmodule // rns2bin
//.-sec.rns2bin
